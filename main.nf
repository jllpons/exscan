#!/usr/bin/env nextflow

include { EXSCAN } from './workflows/exscan'


help_message = """
E X S C A N   P I P E L I N E
=============================
Explore and identify exons through sequence scanning using profile HMMs.

Usage:
    nextflow run exscan.nf --fasta <fasta> --hmmdb <hmm_db>
    nextflow run exscan.nf -params-file <yaml>

Required Arguments:
    --fasta <fasta>           : Input fasta file
    --hmmdb <hmmdb>           : Profile HMM database file
                                Index files from hmmpress must also be located in the same directory

Alternative to Required Arguments:
    -params-file <yaml>       : YAML/JSON file with parameters for each sample
                                Mutually exclusive with --fasta and --hmmdb

Optional Arguments:
    --dom_ieval <val>         : Domain alignment individual e-value filter [default: ${params.dom_ieval}]
                                Domain alignments with **equal or less** than this e-value will be kept
    --fasta_type <val>        : Type of sequences in input `--fasta` file.
                                Choices: {dna, rna, protein} [defalut: $params.fasta_type]
    --gff_intersect <gff>     : If provided, any feature in the GFF file that intersects
                                with a domain alignment will be retained.
                                The information about each intersecting feature will be kept.
    --group_distance <val>    : Group query results within n bps [default: ${params.group_distance}]
    --keep_only_intersect     : Keep only query results that intersect with a GFF feature of the provided GFF file(s)
    --min_alignment_len <val> : Domain alignment minimum length filter [default: ${params.min_alignment_len}]
                                Domain alignments with **EQUAL OR MORE** than this distance will be
    --outdir <outdir>         : Output directory [default: ${params.outdir}]

    --help                    : Print help message and exit
    --version                 : Print version and exit
"""

init_summary = """
E X S C A N   P I P E L I N E   v${params.manifest.version}
======================================
fasta               : ${params.fasta}
hmmdb               : ${params.hmmdb}
dom_ieval           : ${params.dom_ieval}
fasta_type          : ${params.fasta_type}
gff_intersect       : ${params.gff_intersect}
group_distance      : ${params.group_distance}
keep_only_intersect : ${params.keep_only_intersect}
min_alignment_len   : ${params.min_alignment_len}
outdir              : ${params.outdir}

--

Run as              : ${workflow.commandLine}
Started at          : ${workflow.start}
Config files        : ${workflow.configFiles}

--
"""
// container images : ${workflow.containerEngine}:${workflow.container}


// DESC: Validate input arguments and initialize pipeline, printing a small summary
// ARGS: None, uses variables defined at the beginning of the script
// OUTS: `$init_summary` as log message at `INFO` level
//       `$help_message` as stdout if `--help` flag is set
//       `$version` as stdout if `--version` flag is set
//       Proper error message and exit code if required arguments are missing
// RETS: None
def validateParams() {

    // `--help` and `--version` flags
    if (params.help) {
        println help_message
        System.exit(0)
    }
    if (params.version) {
        println "${params.manifest.name} v${params.manifest.version}"
        System.exit(0)
    }

    // Check required arguments
    if (params.fasta == null) {
        println help_message
        log.error "Missing required argument: --fasta"
        System.exit(1)
    }
    if (!file(params.fasta).exists()) {
        log.error "File not found: ${params.fasta}"
        System.exit(1)
    }

    if (params.hmmdb == null) {
        println help_message
        log.error "Missing required argument: --hmmdb"
        System.exit(1)
    }
    if (!file(params.hmmdb).exists()) {
        log.error "File not found: ${params.hmmdb}"
        System.exit(1)
    }

    if (params.fasta_type != 'dna' && params.fasta_type != 'rna' && params.fasta_type != 'protein') {
        log.error "Invalid fasta type: ${params.fasta_type}. Must be one of {dna, rna, protein}"
        System.exit(1)
    }

}


// DESC: Handle hmmdb appropriately so it can be mounted correctly
// ARGS: None, uses variables defined at the beginning of the script
// OUTS: `$params.hmmdb_file` and `$params.hmmdb_dir` as new variables
// RETS: None
def handle_hmmdb() {
    // hmmscan needs access to the files generated by hmmpress,
    // but accepts the hmmdb file as input.
    // When using docker for example, if we only mount the hmmdb file,
    // hmmscan will not be able to find the index files.
    // To solve this, we mount the directory containing the hmmdb file
    // and pass the hmmdb file as input to hmmscan.
    params.hmmdb_file = params.hmmdb.split('/').last()
    params.hmmdb_dir = file(params.hmmdb).getParent()
}


// DESC: Display completion message based on workflow status
// ARGS: None, uses variables defined at the beginning of the script
// OUTS: Completion message at `INFO` or `ERROR` level
// RETS: None
def completionMsg() {

    if (workflow.success) {
        if (workflow.stats.ignoredCount == 0) {
            log.info "Pipeline completed successfully!"
        }
        else {
            log.info "Pipeline completed successully, but with errored processes"
        }
    }
    else {
        log.error "Pipeline completed with errors"
    }

}


// Main workflow


workflow {

    main:

    // Validate input parameters
    validateParams()
    // Handle hmm database paths
    handle_hmmdb()
    // Initialization Summary - Everything looks good so far
    log.info init_summary




    ch_versions = Channel.empty()
    // WORKFLOW: After validation, main workflow is launched here
    EXSCAN(
        params.dom_ieval,
        params.fasta,
        params.fasta_type,
        params.gff_intersect,
        params.group_distance,
        params.hmmdb_dir,
        params.hmmdb_file,
        params.keep_only_intersect,
        params.min_alignment_len,
        ch_versions,
    )
    ch_versions = ch_versions.mix(EXSCAN.out.versions)




    // Save versions of all tools used in the pipeline
    ch_versions.collectFile(
        storeDir: "${params.outdir}/pipeline_info/",
        name: 'versions.yml',
        sort: true,
        newLine: true
    )

    // Display any error encountered during the workflow
    workflow.onComplete {
        completionMsg()
    }
}
